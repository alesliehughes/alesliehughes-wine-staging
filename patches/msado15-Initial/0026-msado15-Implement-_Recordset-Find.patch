From 23a9b5d0259b430048f0ee7998c4104cdce184d9 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 23 Mar 2021 12:30:24 +1100
Subject: [PATCH] msado15: Implement _Recordset Find

---
 dlls/msado15/Makefile.in |   6 +++
 dlls/msado15/filter.l    |  89 +++++++++++++++++++++++++++++++
 dlls/msado15/filter.y    | 111 +++++++++++++++++++++++++++++++++++++++
 dlls/msado15/recordset.c | 100 ++++++++++++++++++++++++++++++++++-
 4 files changed, 304 insertions(+), 2 deletions(-)
 create mode 100644 dlls/msado15/filter.l
 create mode 100644 dlls/msado15/filter.y

diff --git a/dlls/msado15/Makefile.in b/dlls/msado15/Makefile.in
index 9c1fba502c5..81847e997bc 100644
--- a/dlls/msado15/Makefile.in
+++ b/dlls/msado15/Makefile.in
@@ -8,6 +8,12 @@ C_SRCS = \
 	recordset.c \
 	stream.c
 
+LEX_SRCS = \
+	filter.l \
+
+BISON_SRCS = \
+	filter.y
+
 IDL_SRCS = \
 	msado15_classes.idl \
 	msado15_tlb.idl
diff --git a/dlls/msado15/filter.l b/dlls/msado15/filter.l
new file mode 100644
index 00000000000..c00d95c493f
--- /dev/null
+++ b/dlls/msado15/filter.l
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2021 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+%option noyywrap
+%option caseless
+/* %option prefix="filter_" */
+%option noinput nounput never-interactive
+
+%{
+#include <stdio.h>
+
+#define YY_DECL int yylex(void)
+
+#include "wine/debug.h"
+
+#include "filter.tab.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(msado15);
+
+typedef struct _parser_param
+{
+    void* yyscanner;
+} parser_param;
+
+enum operations
+{
+	op_equal,
+	op_not_equal,
+	op_less,
+	op_less_equal,
+	op_greater,
+	op_greater_equal,
+	op_like
+};
+
+enum joined
+{
+	join_none,
+	join_and,
+	join_or
+};
+
+%}
+
+%%
+
+[ \t]           { /* ignore all whitespace */ } ;
+[0-9]+\.[0-9]+ 	{ yylval.fval = atof(yytext); return T_FLOAT; }
+[0-9]+          { yylval.ival = atoi(yytext); return T_INT;   }
+'[^'].*'        {
+                    yylval.sval = malloc(strlen(yytext)-1);
+                    memcpy(yylval.sval, yytext+1, strlen(yytext)-2);
+                    yylval.sval[strlen(yytext)-1] = 0;
+                    return T_STRING;
+                }
+
+\n              { return T_NEWLINE;}
+"("             { /* Ignored for now */ }
+")"             { /* Ignored for now */ }
+
+"="             { yylval.ival = op_equal;         return TOKEN_EQ; }
+">"             { yylval.ival = op_greater;       return TOKEN_GREATER; }
+"<"             { yylval.ival = op_less;          return TOKEN_LESS; }
+"<>"            { yylval.ival = op_not_equal;     return TOKEN_NOT_EQ; }
+">="            { yylval.ival = op_greater_equal; return TOKEN_GREATER_EQ; }
+"<="            { yylval.ival = op_less_equal;    return TOKEN_LESS_EQ; }
+"like"          { yylval.ival = op_like;          return TOKEN_LIKE; }
+
+"and"           { yylval.ival = join_and;         return TOKEN_AND; }
+"or"            { yylval.ival = join_or;          return TOKEN_OR; }
+
+
+[A-Za-z_0-9\.]*    { yylval.token = strdup(yytext); return TOKEN_COLUMN; }
+
+%%
\ No newline at end of file
diff --git a/dlls/msado15/filter.y b/dlls/msado15/filter.y
new file mode 100644
index 00000000000..237e939cd94
--- /dev/null
+++ b/dlls/msado15/filter.y
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2021 Alistair Leslie-Hughes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+%{
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/*#include "msado15_private.h"*/
+
+#define YY_EXTRA_TYPE parser_param*
+/*#include "filter.h"*/
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(msado15);
+
+typedef struct _parser_param
+{
+    void* yyscanner;
+} parser_param;
+
+
+extern int yylex(void);
+extern int yyparse(void);
+
+void yyerror(const char* s);
+%}
+
+%union {
+	char *token;
+	int operation;
+	int join;
+
+	/* Possible values types */
+	int ival;
+	float fval;
+	char *sval;
+}
+
+%token<ival> T_INT
+%token<fval> T_FLOAT
+%token<sval> T_STRING
+
+%token T_NEWLINE
+
+%type<operation> oparations
+
+%token<operation> TOKEN_GREATER
+%token<operation> TOKEN_GREATER_EQ
+%token<operation> TOKEN_LESS
+%token<operation> TOKEN_LESS_EQ
+%token<operation> TOKEN_NOT_EQ
+%token<operation> TOKEN_EQ
+%token<operation> TOKEN_LIKE
+
+%token TOKEN_AND
+%token TOKEN_OR
+
+%token<token> TOKEN_COLUMN
+
+
+%start filter
+
+%%
+
+filter:
+	| filter line
+
+;
+
+line: T_NEWLINE
+	| TOKEN_COLUMN oparations T_INT { printf("%s %d, %d\n", $1, $2, $3); }
+	| TOKEN_COLUMN oparations T_FLOAT { printf("%s %d, %f\n", $1, $2, $3); }
+	| TOKEN_COLUMN oparations T_STRING { printf("%s %d, %s\n", $1, $2, $3); }
+
+	/* Like is always followed by a string */
+	| TOKEN_COLUMN TOKEN_LIKE T_STRING { printf("%s %d, %s\n", $1, $2, $3); }
+
+	| TOKEN_AND { printf(" AND "); }
+	| TOKEN_OR { printf(" OR "); }
+;
+
+oparations: TOKEN_GREATER
+	| TOKEN_GREATER_EQ
+	| TOKEN_LESS
+	| TOKEN_LESS_EQ
+	| TOKEN_NOT_EQ
+	| TOKEN_EQ
+;
+
+%%
+
+void yyerror(const char* s) {
+	//fprintf(stderr, "Parse error: %s\n", s);
+	exit(1);
+}
\ No newline at end of file
diff --git a/dlls/msado15/recordset.c b/dlls/msado15/recordset.c
index f92f7e12d37..16b7baabf36 100644
--- a/dlls/msado15/recordset.c
+++ b/dlls/msado15/recordset.c
@@ -50,6 +50,7 @@ struct recordset
     IRowset           *row_set;
     EditModeEnum      editmode;
     VARIANT            filter;
+    BSTR              criteria;
 
     DBTYPE            *columntypes;
     HACCESSOR         *haccessors;
@@ -1207,6 +1208,8 @@ static void close_recordset( struct recordset *recordset )
     ULONG i;
     IAccessor *accessor;
 
+    SysFreeString(recordset->criteria);
+
     if (recordset->haccessors)
         IRowset_QueryInterface(recordset->row_set, &IID_IAccessor, (void**)&accessor);
 
@@ -2334,9 +2337,101 @@ static HRESULT WINAPI recordset_put_MarshalOptions( _Recordset *iface, MarshalOp
 static HRESULT WINAPI recordset_Find( _Recordset *iface, BSTR criteria, LONG skip_records,
                                       SearchDirectionEnum search_direction, VARIANT start )
 {
-    FIXME( "%p, %s, %ld, %d, %s\n", iface, debugstr_w(criteria), skip_records, search_direction,
+    struct recordset *recordset = impl_from_Recordset( iface );
+    HRESULT hr;
+    WCHAR column[256];
+    WCHAR value[256];
+    WCHAR *p, *c;
+
+    FIXME( "%p, %s, %ld, %d, %s\n", recordset, debugstr_w(criteria), skip_records, search_direction,
            debugstr_variant(&start) );
-    return E_NOTIMPL;
+
+    if (!recordset->criteria || wcscmp(recordset->criteria, criteria) != 0)
+    {
+        SysFreeString(recordset->criteria);
+        recordset->criteria = SysAllocString(criteria);
+
+        /* Parse criteria */
+    }
+
+    p = wcsstr(criteria, L"=");
+    if (p)
+    {
+        VARIANT index, rhs;
+        ULONG datacol = 0;
+        ULONG colcnt = get_column_count(recordset);
+        DataTypeEnum datatype;
+
+        c = p;
+        while (isspace(*c) || *c == '=') --c; /* strip trailing LWS */
+        lstrcpynW(column, criteria, c - criteria + 2);
+
+        FIXME("Column %s\n", debugstr_w(column));
+
+        V_VT(&index) = VT_BSTR;
+        V_BSTR(&index) = column;
+
+        if ((hr = map_index( recordset->fields, &index, &datacol )) != S_OK)
+        {
+            FIXME("No Column name");
+            return hr;
+        }
+
+        field_get_Type(recordset->fields->field[datacol], &datatype);
+        FIXME("Column index %ld, type %d\n", datacol, datatype);
+
+        if (datatype == adBSTR || datatype == adWChar)
+        {
+            int i = 0;
+
+            while (isspace(*p) || *p != '\'') p++;
+            p++; /* Skip ' */
+            while (*p != '\'')
+            {
+                value[i++] = *p;
+                p++;
+            }
+            value[i] = '\0';
+
+            V_VT(&rhs) = VT_BSTR;
+            V_BSTR(&rhs) = value;
+        }
+        else
+        {
+            long val;
+
+            p++; /* Skip = */
+            val = wcstol(p, NULL, 10);
+
+            V_VT(&rhs) = VT_I4;
+            V_I4(&rhs) = val;
+        }
+
+        FIXME("value %s\n", debugstr_variant(&rhs));
+
+        recordset->index += skip_records;
+        for(; recordset->index < recordset->count; recordset->index++)
+        {
+            FIXME("Data %s\n", debugstr_variant(&recordset->data[recordset->index * colcnt + datacol]));
+            if (datatype == adBSTR || datatype == adWChar)
+            {
+                if (lstrcmpW(V_BSTR(&recordset->data[recordset->index * colcnt + datacol]), V_BSTR(&rhs)) == 0)
+                    break;
+            }
+            else
+            {
+                if (V_I4(&recordset->data[recordset->index * colcnt + datacol]) == V_I4(&rhs))
+                    break;
+            }
+        }
+    }
+
+/*    if (search_direction == adSearchForward)
+        recordset->index = recordset->count;
+    else
+        recordset->index = -1;
+*/
+    return S_OK;
 }
 
 static HRESULT WINAPI recordset_Cancel( _Recordset *iface )
@@ -2743,6 +2838,7 @@ HRESULT Recordset_create( void **obj )
     VariantInit( &recordset->filter );
     recordset->columntypes = NULL;
     recordset->haccessors = NULL;
+    recordset->criteria = NULL;
 
     *obj = &recordset->Recordset_iface;
     TRACE( "returning iface %p\n", *obj );
-- 
2.39.2

