From 9216de8ea121a52d745d00d47245a46b8d102879 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 23 Mar 2021 12:30:24 +1100
Subject: [PATCH] msado15: Implement _Recordset Find

Find only supports one Column to filter on.

The parser for this will be the same for both Find/Filter with the only different
is the Filter supports multiple columns.

In trying to keep this patch small, only WSTR/BSTR/Integer have been supported. (The Common cases).
---
 dlls/msado15/Makefile.in       |   6 +
 dlls/msado15/msado15_private.h |  58 +++++++++
 dlls/msado15/recordset.c       | 232 ++++++++++++++++++++++++++++-----
 dlls/msado15/tests/msado15.c   |  19 ++-
 4 files changed, 282 insertions(+), 33 deletions(-)

diff --git a/dlls/msado15/Makefile.in b/dlls/msado15/Makefile.in
index 9c1fba502c5..0c10402269e 100644
--- a/dlls/msado15/Makefile.in
+++ b/dlls/msado15/Makefile.in
@@ -8,6 +8,12 @@ C_SRCS = \
 	recordset.c \
 	stream.c
 
+LEX_SRCS = \
+	filter.l
+
+BISON_SRCS = \
+	filter.y
+
 IDL_SRCS = \
 	msado15_classes.idl \
 	msado15_tlb.idl
diff --git a/dlls/msado15/msado15_private.h b/dlls/msado15/msado15_private.h
index f7062c94b27..56dc9b45367 100644
--- a/dlls/msado15/msado15_private.h
+++ b/dlls/msado15/msado15_private.h
@@ -19,6 +19,64 @@
 #ifndef _WINE_MSADO15_PRIVATE_H_
 #define _WINE_MSADO15_PRIVATE_H_
 
+#define COBJMACROS
+#include "objbase.h"
+#include "msado15_backcompat.h"
+#include "oledb.h"
+#include "sqlucode.h"
+
+#include "wine/list.h"
+#include "wine/debug.h"
+
+struct column_filter
+{
+    struct list entry;
+
+    LONG column;
+    LONG condition;
+    VARIANT value;
+};
+
+struct fields;
+struct recordset
+{
+    _Recordset         Recordset_iface;
+    ADORecordsetConstruction ADORecordsetConstruction_iface;
+    ISupportErrorInfo  ISupportErrorInfo_iface;
+    LONG               refs;
+    LONG               state;
+    struct fields     *fields;
+    LONG               count;
+    LONG               allocated;
+    LONG               index;
+    VARIANT           *data;
+    CursorLocationEnum cursor_location;
+    CursorTypeEnum     cursor_type;
+    IRowset           *row_set;
+    EditModeEnum      editmode;
+    VARIANT            filter;
+    BSTR              criteria;
+
+    DBTYPE            *columntypes;
+    HACCESSOR         *haccessors;
+
+    struct list       filters;
+};
+
+typedef struct _parser_param
+{
+    void* yyscanner;
+
+    struct recordset *recordset;
+} parser_param;
+
+#define YY_EXTRA_TYPE parser_param*
+
+BOOL recordset_parse_filter(WCHAR *filter, struct recordset *recordset) DECLSPEC_HIDDEN;
+void filter_add_integer_column(struct recordset *recordset, char *name, LONG cond, LONG value) DECLSPEC_HIDDEN;
+void filter_add_float_column(struct recordset *recordset, char *name, LONG cond, float value) DECLSPEC_HIDDEN;
+void filter_add_string_column(struct recordset *recordset, char *name, LONG cond, char *value) DECLSPEC_HIDDEN;
+
 #define MAKE_ADO_HRESULT( err ) MAKE_HRESULT( SEVERITY_ERROR, FACILITY_CONTROL, err )
 
 HRESULT Command_create( void ** ) DECLSPEC_HIDDEN;
diff --git a/dlls/msado15/recordset.c b/dlls/msado15/recordset.c
index e859962fc2a..6ee1734ef85 100644
--- a/dlls/msado15/recordset.c
+++ b/dlls/msado15/recordset.c
@@ -20,40 +20,13 @@
 #include <assert.h>
 #include "windef.h"
 #include "winbase.h"
-#define COBJMACROS
-#include "objbase.h"
-#include "msado15_backcompat.h"
-#include "oledb.h"
-#include "sqlucode.h"
-
+#include "msado15_private.h"
 #include "wine/debug.h"
 
-#include "msado15_private.h"
+#include "filter.tab.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(msado15);
 
-struct fields;
-struct recordset
-{
-    _Recordset         Recordset_iface;
-    ADORecordsetConstruction ADORecordsetConstruction_iface;
-    ISupportErrorInfo  ISupportErrorInfo_iface;
-    LONG               refs;
-    LONG               state;
-    struct fields     *fields;
-    LONG               count;
-    LONG               allocated;
-    LONG               index;
-    VARIANT           *data;
-    CursorLocationEnum cursor_location;
-    CursorTypeEnum     cursor_type;
-    IRowset           *row_set;
-    EditModeEnum      editmode;
-    VARIANT            filter;
-
-    DBTYPE            *columntypes;
-    HACCESSOR         *haccessors;
-};
+WINE_DEFAULT_DEBUG_CHANNEL(msado15);
 
 struct fields
 {
@@ -986,6 +959,66 @@ static inline WCHAR *heap_strdupAtoW(const char *str)
     return ret;
 }
 
+static LONG find_column_index(struct fields *fields, char *name)
+{
+    VARIANT column;
+    LONG ret = -1;
+    ULONG index;
+    WCHAR *str = heap_strdupAtoW(name);
+
+    V_VT(&column) = VT_BSTR;
+    V_BSTR(&column) = SysAllocString(str);
+
+    free(str);
+
+    if (map_index(fields, &column, &index) == S_OK)
+        ret = index;
+    VariantClear(&column);
+
+    return ret;
+}
+
+void filter_add_integer_column(struct recordset *recordset, char *name, LONG cond, LONG value)
+{
+    struct column_filter *filter;
+
+    filter = calloc(1, sizeof(*filter));
+    filter->column = find_column_index(recordset->fields, name);
+    filter->condition = cond;
+    V_VT(&filter->value) = VT_I4;
+    V_I4(&filter->value) = value;
+
+    list_add_head(&recordset->filters, &filter->entry);
+}
+
+void filter_add_float_column(struct recordset *recordset, char *name, LONG cond, float value)
+{
+    struct column_filter *filter;
+
+    filter = calloc(1, sizeof(*filter));
+    filter->column = find_column_index(recordset->fields, name);
+    filter->condition = cond;
+    V_VT(&filter->value) = VT_I8;
+    V_I8(&filter->value) = value;
+
+    list_add_head(&recordset->filters, &filter->entry);
+}
+
+void filter_add_string_column(struct recordset *recordset, char *name, LONG cond, char *value)
+{
+    struct column_filter *filter;
+    WCHAR *str = heap_strdupAtoW(value);
+
+    filter = calloc(1, sizeof(*filter));
+    filter->column = find_column_index(recordset->fields, name);
+    filter->condition = cond;
+    V_VT(&filter->value) = VT_BSTR;
+    V_BSTR(&filter->value) = SysAllocString(str);
+    free(str);
+
+    list_add_head(&recordset->filters, &filter->entry);
+}
+
 static HRESULT WINAPI fields_get_Item( Fields *iface, VARIANT index, Field **obj )
 {
     struct fields *fields = impl_from_Fields( iface );
@@ -1199,6 +1232,20 @@ static HRESULT fields_create( struct recordset *recordset, struct fields **ret )
     return S_OK;
 }
 
+static void clear_recordset_filter(struct recordset *recordset)
+{
+    struct column_filter *filters, *filters2;
+
+    LIST_FOR_EACH_ENTRY_SAFE(filters, filters2, &recordset->filters, struct column_filter, entry)
+    {
+        list_remove(&filters->entry);
+        VariantClear(&filters->value);
+        free(filters);
+    }
+    SysFreeString(recordset->criteria);
+    recordset->criteria = NULL;
+}
+
 static inline struct recordset *impl_from_Recordset( _Recordset *iface )
 {
     return CONTAINING_RECORD( iface, struct recordset, Recordset_iface );
@@ -1223,6 +1270,8 @@ static void close_recordset( struct recordset *recordset )
     ULONG i;
     IAccessor *accessor;
 
+    clear_recordset_filter(recordset);
+
     if (recordset->haccessors)
         IRowset_QueryInterface(recordset->row_set, &IID_IAccessor, (void**)&accessor);
 
@@ -2326,12 +2375,129 @@ static HRESULT WINAPI recordset_put_MarshalOptions( _Recordset *iface, MarshalOp
     return E_NOTIMPL;
 }
 
+static BOOL column_match_string(int condition, BSTR col_data, BSTR filter_data)
+{
+    BOOL match = FALSE;
+
+    switch (condition)
+    {
+        case TOKEN_EQ:
+            match = lstrcmpW(col_data, filter_data) == 0;
+            break;
+        case TOKEN_NOT_EQ:
+            match = lstrcmpW(col_data, filter_data) != 0;
+            break;
+        case TOKEN_LIKE:
+            FIXME("LIKE currently not supported\n");
+            break;
+        default:
+            FIXME("Unsupported condition %d\n", condition);
+    }
+
+    return match;
+}
+
+static BOOL column_match_integer(int condition, INT col_data, INT filter_data)
+{
+    BOOL match = FALSE;
+
+    switch (condition)
+    {
+        case TOKEN_EQ:
+            match = col_data == filter_data;
+            break;
+        case TOKEN_NOT_EQ:
+            match = col_data != filter_data;
+            break;
+        case TOKEN_LESS:
+            match = col_data < filter_data;
+            break;
+        case TOKEN_LESS_EQ:
+            match = col_data <= filter_data;
+            break;
+        case TOKEN_GREATER:
+            match = col_data > filter_data;
+            break;
+        case TOKEN_GREATER_EQ:
+            match = col_data >= filter_data;
+            break;
+        default:
+            FIXME("Unsupported condition %d\n", condition);
+    }
+
+    return match;
+}
+
 static HRESULT WINAPI recordset_Find( _Recordset *iface, BSTR criteria, LONG skip_records,
                                       SearchDirectionEnum search_direction, VARIANT start )
 {
-    FIXME( "%p, %s, %ld, %d, %s\n", iface, debugstr_w(criteria), skip_records, search_direction,
+    struct recordset *recordset = impl_from_Recordset( iface );
+    struct column_filter *filters;
+    DataTypeEnum datatype;
+    BOOL found = FALSE;
+    ULONG colcnt;
+
+    TRACE( "%p, %s, %ld, %d, %s\n", recordset, debugstr_w(criteria), skip_records, search_direction,
            debugstr_variant(&start) );
-    return E_NOTIMPL;
+
+    if (recordset->state != adStateOpen) return MAKE_ADO_HRESULT( adErrObjectClosed );
+
+    if (!recordset->criteria || wcscmp(recordset->criteria, criteria) != 0)
+    {
+        clear_recordset_filter(recordset);
+
+        recordset->criteria = SysAllocString(criteria);
+
+        /* Parse criteria */
+        recordset_parse_filter(criteria, recordset);
+    }
+
+    if (list_count(&recordset->filters) != 1)
+    {
+        WARN("Invalid number of filters.\n");
+        clear_recordset_filter(recordset);
+        return MAKE_ADO_HRESULT( adErrDataConversion );
+    }
+
+    colcnt = get_column_count(recordset);
+
+    filters = LIST_ENTRY(list_head(&recordset->filters), struct column_filter, entry);
+    field_get_Type(recordset->fields->field[filters->column], &datatype);
+
+    recordset->index += skip_records;
+    for(; recordset->index < recordset->count; recordset->index++)
+    {
+        found = FALSE;
+
+        switch(datatype)
+        {
+            case adBSTR:
+            case adWChar:
+            {
+                found = column_match_string(filters->condition,
+                                            V_BSTR(&recordset->data[recordset->index * colcnt + filters->column]),
+                                            V_BSTR(&filters->value));
+                break;
+            }
+            case adInteger:
+            {
+                found = column_match_integer(filters->condition,
+                                         V_I4(&recordset->data[recordset->index * colcnt + filters->column]),
+                                         V_I4(&filters->value));
+                break;
+            }
+            default:
+                FIXME("Unsupported datatype %d\n", datatype);
+        }
+
+        if (found)
+        {
+            TRACE("Return record %ld\n", recordset->index);
+            break;
+        }
+    }
+
+    return S_OK;
 }
 
 static HRESULT WINAPI recordset_Cancel( _Recordset *iface )
@@ -2738,6 +2904,8 @@ HRESULT Recordset_create( void **obj )
     VariantInit( &recordset->filter );
     recordset->columntypes = NULL;
     recordset->haccessors = NULL;
+    recordset->criteria = NULL;
+    list_init(&recordset->filters);
 
     *obj = &recordset->Recordset_iface;
     TRACE( "returning iface %p\n", *obj );
diff --git a/dlls/msado15/tests/msado15.c b/dlls/msado15/tests/msado15.c
index 57e7356c333..4c527f032d4 100644
--- a/dlls/msado15/tests/msado15.c
+++ b/dlls/msado15/tests/msado15.c
@@ -57,7 +57,7 @@ static void test_Recordset(void)
     VARIANT missing, val, index;
     CursorLocationEnum location;
     CursorTypeEnum cursor;
-    BSTR name;
+    BSTR name, crit;
     HRESULT hr;
     VARIANT bookmark, filter;
     EditModeEnum editmode;
@@ -143,6 +143,12 @@ static void test_Recordset(void)
     hr = _Recordset_put_Filter( recordset, filter );
     ok( hr == S_OK, "got %08lx\n", hr );
 
+    crit = SysAllocString(L"colu1=1");
+    V_VT( &index ) = VT_EMPTY;
+    hr = _Recordset_Find( recordset, crit, 0, adSearchForward, index );
+    ok( hr == MAKE_ADO_HRESULT( adErrObjectClosed ), "got %08lx\n", hr );
+    SysFreeString(crit);
+
     VariantInit( &missing );
     hr = _Recordset_AddNew( recordset, missing, missing );
     ok( hr == MAKE_ADO_HRESULT( adErrObjectClosed ), "got %08lx\n", hr );
@@ -229,6 +235,17 @@ static void test_Recordset(void)
     hr = _Recordset_Open( recordset, missing, missing, adOpenStatic, adLockBatchOptimistic, adCmdUnspecified );
     ok( hr == MAKE_ADO_HRESULT( adErrObjectOpen ), "got %08lx\n", hr );
 
+    V_VT( &index ) = VT_EMPTY;
+    crit = SysAllocString(L"field = 1 OR field = 2");
+    hr = _Recordset_Find(recordset, crit, 0, adSearchForward, index);
+    ok( hr == MAKE_ADO_HRESULT( adErrDataConversion ), "got %08lx\n", hr );
+    SysFreeString(crit);
+
+    crit = SysAllocString(L"");
+    hr = _Recordset_Find(recordset, crit, 0, adSearchForward, index);
+    ok( hr == MAKE_ADO_HRESULT( adErrDataConversion ), "got %08lx\n", hr );
+    SysFreeString(crit);
+
     state = -1;
     hr = _Recordset_get_State( recordset, &state );
     ok( hr == S_OK, "got %08lx\n", hr );
-- 
2.40.0

