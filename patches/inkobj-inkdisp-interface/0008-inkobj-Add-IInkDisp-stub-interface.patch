From f7375ade59b04b5cebbc04c67dd6e39c46c24a65 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 9 Sep 2025 16:21:40 +1000
Subject: [PATCH] inkobj: Add IInkDisp stub interface

---
 dlls/inkobj/Makefile.in       |   1 -
 dlls/inkobj/inkobj.c          | 433 ++++++++++++++++++++++++++++++++++
 dlls/inkobj/inkobj_internal.h |   1 +
 3 files changed, 434 insertions(+), 1 deletion(-)

diff --git a/dlls/inkobj/Makefile.in b/dlls/inkobj/Makefile.in
index f1f93f4973f..4dad90d609c 100644
--- a/dlls/inkobj/Makefile.in
+++ b/dlls/inkobj/Makefile.in
@@ -1,5 +1,4 @@
 MODULE    = inkobj.dll
-IMPORTS   = uuid
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
diff --git a/dlls/inkobj/inkobj.c b/dlls/inkobj/inkobj.c
index 1ee6125e4ee..dc30bdd9ea7 100644
--- a/dlls/inkobj/inkobj.c
+++ b/dlls/inkobj/inkobj.c
@@ -19,11 +19,444 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(inkobj);
 
+struct ink_disp
+{
+    IInkDisp IInkDisp_iface;
+    LONG ref;
+};
+
+static inline struct ink_disp *impl_from_IInkDisp( IInkDisp *iface )
+{
+    return CONTAINING_RECORD( iface, struct ink_disp, IInkDisp_iface );
+}
+
+/*** IUnknown methods ***/
+static HRESULT WINAPI inkdisp_QueryInterface(IInkDisp *iface, REFIID riid, void **obj)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+    TRACE( "%p, %s, %p\n", iface, debugstr_guid(riid), obj );
+
+    *obj = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown)  ||
+        IsEqualIID(riid, &IID_IDispatch) ||
+        IsEqualIID(riid, &IID_IInkDisp))
+    {
+        *obj = &ink_disp->IInkDisp_iface;
+    }
+    else
+    {
+        FIXME( "interface %s not implemented\n", debugstr_guid(riid) );
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef( (IUnknown*)*obj );
+    return S_OK;
+}
+
+
+static ULONG WINAPI inkdisp_AddRef(IInkDisp *iface)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+    return InterlockedIncrement( &ink_disp->ref );
+}
+
+static ULONG WINAPI inkdisp_Release(IInkDisp *iface)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+    LONG ref = InterlockedDecrement( &ink_disp->ref );
+    if (!ref)
+    {
+        free( ink_disp );
+    }
+    return ref;
+}
+
+static HRESULT WINAPI inkdisp_GetTypeInfoCount(IInkDisp *iface, UINT *pctinfo)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, pctinfo);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_GetTypeInfo(IInkDisp *iface, UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    TRACE("%p, %u, %lx, %p.\n", ink_disp, iTInfo, lcid, ppTInfo);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_GetIDsOfNames(IInkDisp *iface, REFIID riid, LPOLESTR *rgszNames, UINT cNames,
+    LCID lcid, DISPID *rgDispId)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    TRACE("%p, %s, %p, %u, %lx, %p.\n", ink_disp, debugstr_guid(riid), rgszNames, cNames, lcid, rgDispId);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_Invoke(IInkDisp *iface, DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
+    DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    TRACE("%p, %ld, %s, %lx, %d, %p, %p, %p, %p.\n", ink_disp, dispIdMember, debugstr_guid(riid),
+          lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_get_Strokes(IInkDisp *iface, IInkStrokes **strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_get_ExtendedProperties(IInkDisp *iface, IInkExtendedProperties **properties)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, properties);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_get_Dirty(IInkDisp *iface, VARIANT_BOOL *dirty)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, dirty);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_put_Dirty(IInkDisp *iface, VARIANT_BOOL Dirty)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %d\n", ink_disp, Dirty);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_get_CustomStrokes(IInkDisp *iface, IInkCustomStrokes **strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_GetBoundingBox(IInkDisp *iface, InkBoundingBoxMode mode, IInkRectangle **rect)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %d, %p\n", ink_disp, mode, rect);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_DeleteStrokes(IInkDisp *iface, IInkStrokes *strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_DeleteStroke(IInkDisp *iface, IInkStrokeDisp *strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_ExtractStrokes(IInkDisp *iface, IInkStrokes *strokes, InkExtractFlags flags,
+            IInkDisp **ink)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %d, %p\n", ink_disp, flags, ink);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_ExtractWithRectangle(IInkDisp *iface, IInkRectangle *rectangle, InkExtractFlags flags,
+           IInkDisp **ink)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p, %d, %p\n", ink_disp, rectangle, flags, ink);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_Clip(IInkDisp *iface, IInkRectangle *rectangle)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, rectangle);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_Clone(IInkDisp *iface, IInkDisp **ink)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p\n", ink_disp, ink);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_HitTestCircle(IInkDisp *iface, LONG x, LONG y, float radius, IInkStrokes **strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %ld, %ld, %f, %p\n", ink_disp, x, y, radius, strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_HitTestWithRectangle(IInkDisp *iface, IInkRectangle *rectangle,
+            float IntersectPercent, IInkStrokes **strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p, %f, %p\n", ink_disp, rectangle, IntersectPercent, strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_HitTestWithLasso(IInkDisp *iface, VARIANT points, float percent,
+    VARIANT *lasso, IInkStrokes **strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %s, %f, %p, %p\n", ink_disp, debugstr_variant(&points), percent, lasso, strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_NearestPoint(IInkDisp *iface, LONG x, LONG y, float *point_on,
+    float *distance, IInkStrokeDisp **stroke)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %ld, %ld, %p, %p, %p\n", ink_disp, x, y, point_on, distance, stroke );
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_CreateStrokes(IInkDisp *iface, VARIANT ids, IInkStrokes **strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %s, %p\n", ink_disp, debugstr_variant(&ids), strokes);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_AddStrokesAtRectangle(IInkDisp *iface, IInkStrokes *strokes, IInkRectangle *rect)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p, %p\n", ink_disp, strokes, rect);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_Save(IInkDisp *iface, InkPersistenceFormat persistence,
+    InkPersistenceCompressionMode mode, VARIANT *data)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %d, %d, %p\n", ink_disp, persistence, mode, data);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_Load(IInkDisp *iface, VARIANT data)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %s\n", ink_disp, debugstr_variant(&data));
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_CreateStroke(IInkDisp *iface, VARIANT data, VARIANT description, IInkStrokeDisp **stroke)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %s, %s, %p\n", ink_disp, debugstr_variant(&data), debugstr_variant(&description), stroke);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_ClipboardCopyWithRectangle(IInkDisp *iface, IInkRectangle *Rectangle, InkClipboardFormats ClipboardFormats,
+    InkClipboardModes ClipboardModes, IDataObject **DataObject)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p, %d, %d, %p\n", ink_disp, Rectangle, ClipboardFormats, ClipboardModes, DataObject);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_ClipboardCopy(IInkDisp *iface, IInkStrokes *strokes, InkClipboardFormats ClipboardFormats,
+    InkClipboardModes ClipboardModes, IDataObject **DataObject)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p, %d, %d, %p\n", ink_disp, strokes, ClipboardFormats, ClipboardModes, DataObject);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_CanPaste(IInkDisp *iface, IDataObject *DataObject, VARIANT_BOOL *CanPaste)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p, %p, %p\n", ink_disp, DataObject, CanPaste);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI inkdisp_ClipboardPaste(IInkDisp *iface, LONG x, LONG y, IDataObject *DataObject, IInkStrokes **Strokes)
+{
+    struct ink_disp *ink_disp = impl_from_IInkDisp( iface );
+
+    FIXME("%p\n", ink_disp);
+
+    return E_NOTIMPL;
+}
+
+static const struct IInkDispVtbl ink_disp_vtbl =
+{
+    inkdisp_QueryInterface,
+    inkdisp_AddRef,
+    inkdisp_Release,
+    inkdisp_GetTypeInfoCount,
+    inkdisp_GetTypeInfo,
+    inkdisp_GetIDsOfNames,
+    inkdisp_Invoke,
+    inkdisp_get_Strokes,
+    inkdisp_get_ExtendedProperties,
+    inkdisp_get_Dirty,
+    inkdisp_put_Dirty,
+    inkdisp_get_CustomStrokes,
+    inkdisp_GetBoundingBox,
+    inkdisp_DeleteStrokes,
+    inkdisp_DeleteStroke,
+    inkdisp_ExtractStrokes,
+    inkdisp_ExtractWithRectangle,
+    inkdisp_Clip,
+    inkdisp_Clone,
+    inkdisp_HitTestCircle,
+    inkdisp_HitTestWithRectangle,
+    inkdisp_HitTestWithLasso,
+    inkdisp_NearestPoint,
+    inkdisp_CreateStrokes,
+    inkdisp_AddStrokesAtRectangle,
+    inkdisp_Save,
+    inkdisp_Load,
+    inkdisp_CreateStroke,
+    inkdisp_ClipboardCopyWithRectangle,
+    inkdisp_ClipboardCopy,
+    inkdisp_CanPaste,
+    inkdisp_ClipboardPaste
+};
+
+static HRESULT WINAPI ClassFactory_QueryInterface(IClassFactory *iface, REFIID riid, void **ppv)
+{
+    *ppv = NULL;
+
+    if(IsEqualGUID(&IID_IUnknown, riid)) {
+        TRACE("(%p)->(IID_IUnknown %p)\n", iface, ppv);
+        *ppv = iface;
+    }else if(IsEqualGUID(&IID_IClassFactory, riid)) {
+        TRACE("(%p)->(IID_IClassFactory %p)\n", iface, ppv);
+        *ppv = iface;
+    }
+
+    if(*ppv) {
+        IUnknown_AddRef((IUnknown*)*ppv);
+        return S_OK;
+    }
+
+    WARN("(%p)->(%s %p)\n", iface, debugstr_guid(riid), ppv);
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ClassFactory_AddRef(IClassFactory *iface)
+{
+    TRACE("(%p)\n", iface);
+    return 2;
+}
+
+static ULONG WINAPI ClassFactory_Release(IClassFactory *iface)
+{
+    TRACE("(%p)\n", iface);
+    return 1;
+}
+
+HRESULT WINAPI inkdisp_CreateInstance(IClassFactory *iface, IUnknown *outer, REFIID riid, void **ppv)
+{
+    struct ink_disp *disp;
+
+    TRACE("(%p %s %p)\n", outer, debugstr_guid(riid), ppv);
+
+    if (!(disp = malloc( sizeof(*disp) ))) return E_OUTOFMEMORY;
+    disp->IInkDisp_iface.lpVtbl = &ink_disp_vtbl;
+    disp->ref = 1;
+
+    *ppv = &disp->IInkDisp_iface;
+    TRACE( "returning iface %p\n", *ppv );
+    return S_OK;
+}
+
+static HRESULT WINAPI ClassFactory_LockServer(IClassFactory *iface, BOOL fLock)
+{
+    TRACE("(%p)->(%x)\n", iface, fLock);
+    return S_OK;
+}
+
+static const IClassFactoryVtbl cfinkdisplVtbl = {
+    ClassFactory_QueryInterface,
+    ClassFactory_AddRef,
+    ClassFactory_Release,
+    inkdisp_CreateInstance,
+    ClassFactory_LockServer
+};
+
+static IClassFactory cf_inkdisp = { &cfinkdisplVtbl };
+
 /*****************************************************
  *    DllGetClassObject [INKOBJ.@]
  */
 HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
 {
+    TRACE("%s %s %p\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+
+    if (IsEqualGUID(&CLSID_InkDisp, rclsid))
+    {
+        return IClassFactory_QueryInterface(&cf_inkdisp, riid, ppv);
+    }
+
     FIXME("Not implemented. Requested class was:%s\n", debugstr_guid(rclsid));
+
     return CLASS_E_CLASSNOTAVAILABLE;
 }
diff --git a/dlls/inkobj/inkobj_internal.h b/dlls/inkobj/inkobj_internal.h
index 730a0bdd6a6..770b76be60a 100644
--- a/dlls/inkobj/inkobj_internal.h
+++ b/dlls/inkobj/inkobj_internal.h
@@ -25,6 +25,7 @@
 
 #define COBJMACROS
 #include "winuser.h"
+#include "initguid.h"
 #include "ole2.h"
 #include "msinkaut.h"
 
-- 
2.51.0

